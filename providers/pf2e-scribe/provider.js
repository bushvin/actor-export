import { scribeProvider } from '../../scripts/lib/providers/ScribeProvider.js';
import { pf2eHelper } from '../../scripts/lib/helpers/PF2eHelper.js';

const mapper = new scribeProvider(actor);
const character = pf2eHelper.getActorObject(game, actor);
let fileName;
// scribeProvider.class contains all scribe classes which handle the raw object
// passed to it.

mapper.scribe('all', new scribeProvider.class.scribeWatermark('Generated by actor-export'));
mapper.scribe('all', new scribeProvider.class.scribeTitle(character.name));

/**
 * actor-creature
 */
fileName = 'actor-creature';
mapper.scribe(fileName, new scribeProvider.class.scribeCreature(character));
// mapper.scribe('actor-creature', new scribeProvider.class.scribeCreature(actor).scribify());

/**
 * actor-abc
 */
// Ancestry and Heritage
fileName = 'actor-abc';
mapper.scribe(fileName, new scribeProvider.class.scribeHead(character.name, `This is the ABC of ${character.name}`));

mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, `Ancestry - ${character.ancestry.name}`));
mapper.scribe(fileName, new scribeProvider.class.scribeText(character.ancestry.description));

mapper.scribe(fileName, new scribeProvider.class.scribeHeader(2, `Heritage - ${character.heritage.name}`));
mapper.scribe(fileName, new scribeProvider.class.scribeText(character.heritage.description));

// Ancestry Features
mapper.scribe(fileName, new scribeProvider.class.scribeHeader(2, `Ancestry Features`));
character.ancestryAndHeritageAbilities
    .sort((a, b) => (a.displayName < b.displayName ? -1 : a.displayName > b.displayName ? 1 : 0))
    .forEach((f) => {
        mapper.scribe(fileName, new scribeProvider.class.scribeHeader(3, f.displayName));
        mapper.scribe(fileName, new scribeProvider.class.scribeText(f.description));
    });

console.log(character.ancestryAndHeritageAbilities);

// Background
mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, `Background - ${character.background.name}`));
mapper.scribe(fileName, new scribeProvider.class.scribeText(character.background.description));

// Class
mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, `Class - ${character.class.name}`));
mapper.scribe(fileName, new scribeProvider.class.scribeText(character.class.description));

// Class Features
if (character.classFeatures.length > 0) {
    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(2, 'Class features'));
    character.classFeatures
        .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
        .forEach((f) => {
            mapper.scribe(fileName, new scribeProvider.class.scribeHeader(3, `${f.name}`));
            mapper.scribe(fileName, new scribeProvider.class.scribeText(f.description));
        });
}

// Feats
const feats = character.classFeats
    .concat(character.ancestryFeats)
    .concat(character.backgroundSkillFeats)
    .concat(character.skillFeats)
    .concat(character.generalFeats);
if (feats.length > 0) {
    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Feats'));
    feats
        .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
        .forEach((f) => {
            mapper.scribe(fileName, new scribeProvider.class.scribeCharacterFeat(f, 2));
        });
}

// Spells
const knownSpells = character.knownSpells.filter((f) => !f.heightened);
if (knownSpells.length > 0) {
    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Spells'));
    knownSpells.forEach((s) => {
        mapper.scribe(fileName, new scribeProvider.class.scribeCharacterSpell(s, 2));
    });
}

// Rituals
if (character.knownRituals.length > 0) {
    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Rituals'));
    character.knownRituals.forEach((r) => {
        mapper.scribe(fileName, new scribeProvider.class.scribeCharacterRitual(r, 2));
    });
}
// Formulas
if (character.knownFormulas.length > 0) {
    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Formulas'));
    character.knownFormulas
        .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
        .forEach((f) => {
            mapper.scribe(fileName, new scribeProvider.class.scribeCharacterFormula(f, 2));
        });
}

/**
 * actor-actions
 */
try {
    fileName = 'actor-actions';
    mapper.scribe(
        fileName,
        new scribeProvider.class.scribeHead(character.name, `These are the actions of ${character.name}`)
    );
    // strikes
    if (character.strikes.length > 0) {
        mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Strikes', 1));
        mapper.scribe(fileName, new scribeProvider.class.scribeText('item('));
        character.strikes
            .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
            .sort((a, b) => (a.isMelee < b.isMelee ? 1 : a.isMelee > b.isMelee ? -1 : 0))
            .forEach((s) => {
                mapper.scribe(fileName, new scribeProvider.class.scribeCharacterStrike(s));
                mapper.scribe(fileName, new scribeProvider.class.scribeText(''));
            });
        mapper.scribe(fileName, new scribeProvider.class.scribeText(')'));
    }

    // actions
    if (character.activities.length > 0) {
        let activity;
        character.activities
            .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
            .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))
            .forEach((a) => {
                if (a.type !== activity) {
                    const title = a.type === 'action' ? 'Actions' : a.type === 'free' ? 'Free Actions' : 'Reactions';
                    if (typeof activity !== 'undefined') {
                        mapper.scribe(fileName, new scribeProvider.class.scribeText(')'));
                    }
                    mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, title, 1));
                    mapper.scribe(fileName, new scribeProvider.class.scribeText('item('));
                    activity = a.type;
                }
                mapper.scribe(fileName, new scribeProvider.class.scribeCharacterActivity(a));
            });
        mapper.scribe(fileName, new scribeProvider.class.scribeText(')'));
    }
    if (character.knownSpells.filter((f) => !f.heightened).length > 0) {
        const spellProficiency = character.highestSpellProficiency;
        const headerCells = ['Spell', 'actions', 'Defense', 'rank', 'range', 'AofE', 'target', 'Source'];
        const scribeSpellTable = new scribeProvider.class.scribeTable('Spell List', headerCells);
        character.knownSpells
            .filter((f) => !f.heightened)
            .sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0))
            .forEach((s) => {
                const activity = pf2eHelper.formatSpellCastingTime(s.castingTime, pf2eHelper.scribeActivityGlyphs);
                let defense = '';
                if (s.save) {
                    defense = s.saveIsBasic ? 'Basic ' : '';
                    if (s.saveStatistic === 'ac') {
                        defense = defense + `AC ${pf2eHelper.quantifyNumber(spellProficiency.attack.modifier)}`;
                    } else {
                        defense = defense + `${s.saveStatistic} ${spellProficiency.spell.modifier}`;
                    }
                }
                const spellType = s.isCantrip ? 'Cantrip' : s.isFocusSpell ? 'Focus' : 'Spell';
                const rank = `${spellType} ${s.rank}`;
                const reference = pf2eHelper.abbreviateSource(s.reference);
                scribeSpellTable.addContentRow([s.name, activity, defense, rank, s.range, s.area, s.target, reference]);
            });
        mapper.scribe(fileName, new scribeProvider.class.scribeHeader(1, 'Spells', 1));
        mapper.scribe(fileName, scribeSpellTable);
    }
} catch (error) {
    console.error('error:', error.message);
    throw new Error(error);
}

export { mapper };
